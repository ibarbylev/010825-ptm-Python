## Общая структура распределения памяти процесса

Обычно (в ОС Linux, Windows, macOS, и для Python в частности) процесс получает адресное пространство,  
которое делится на **сегменты**. Схематично это можно изобразить так:

```
Высокие адреса памяти
─────────────────────────────────────
|   Kernel space (ядро ОС)          |  ← процесс сюда напрямую не лезет
─────────────────────────────────────
|   Stack (стек вызовов)            |  ← растёт вниз (к меньшим адресам)
─────────────────────────────────────
|                                   |
|   (свободная память)              |
|                                   |
─────────────────────────────────────
|   Heap (куча)                     |  ← растёт вверх (к большим адресам)
─────────────────────────────────────
|   Data segment                    |  ← глобальные и статические данные
─────────────────────────────────────
|   Code segment (text segment)     |  ← машинный код программы
Низкие адреса памяти
```

---

## Основные сегменты

1. **Code segment (текстовый сегмент)**

   * хранит скомпилированный код программы (в Python это сама интерпретаторная логика и байткод).
   * обычно только для чтения.

2. **Data segment**

   * глобальные и статические переменные.
   * делится на `.data` (инициализированные) и `.bss` (неинициализированные).

3. **Heap (куча)**

   * выделяется динамически во время работы программы.
   * хранит объекты, которые создаются «на лету» (в Python это **все объекты: int, list, dict, class и т.д.**).
   * растёт **вверх** (к большим адресам).
   * управляется сборщиком мусора (GC) или вручную (в C).

4. **Stack (стек вызовов)**

   * хранит **кадры вызовов функций (stack frames)**.
   * в каждом кадре: локальные переменные, аргументы функции, адрес возврата.
   * растёт **вниз** (к меньшим адресам).
   * автоматически очищается при выходе из функции.

---

## Важное уточнение

* **Стек вызовов (call stack)** — это системный механизм управления функциями (каждый вызов функции = новый «кадр стека»).
* **Стек как структура данных внутри программы (`list`, `collections.deque`)** — 
  * это просто программная абстракция (LIFO-структура), которая хранится… где? 
    * В **куче**, как и все остальные объекты Python!

То есть:

* **Call stack** = «системный стек», управляемый ОС и процессором.
* **Stack внутри Python** = обычный объект `list` или `deque`, который сам хранится в куче.

Иными словами: 

**Стек вызовов (call stack)** не имеет НИЧЕГО общего со стеком внутри программы (кроме имени, разумеется).  
Физически они находятся в разных местах памяти.


