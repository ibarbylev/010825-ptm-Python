# Сравнение методов `.get()` и `.setdefault()`

## 1. Вспоминаем эти методы

### 1.1. Метод `dict.get()`

```python
dict.get(key, default=None)
```

* Возвращает значение по ключу, если ключ есть.
* Если ключа **нет**, возвращает `default` (по умолчанию `None`).
* ⚠️ **Не изменяет** сам словарь.

```python
d = {'a': 1, 'b': 2}

print(d.get('a'))        # 1
print(d.get('c'))        # None
print(d.get('c', 0))     # 0

print(d)  # {'a': 1, 'b': 2} — словарь не изменился
```

---

## 1.2. Метод `dict.setdefault()`

```python
dict.setdefault(key, default=None)
```

* Если ключ **существует**, возвращает его значение.
* Если ключа **нет**, создаёт новую пару `key: default` в словаре.
* ⚠️ **Изменяет** словарь, если ключа ещё не было.

```python
d = {'a': 1, 'b': 2}

print(d.setdefault('a'))        # 1 (уже есть)
print(d.setdefault('c'))        # None (создался со значением None)
print(d.setdefault('d', 0))     # 0 (создался со значением 0)

print(d)
# {'a': 1, 'b': 2, 'c': None, 'd': 0}
```

---

## 2. Ключевые различия

| Особенность                                 | `get()`                         | `setdefault()`                         |
| ------------------------------------------- |---------------------------------|----------------------------------------|
| Возвращает значение по ключу                | ✅ Да                           | ✅ Да                                   |
| Если ключ отсутствует — добавляет в словарь | ❌ Нет                          | ✅ Да                                   |
| Изменяет словарь                            | ❌ Нет                          | ✅ Да (если ключа не было)              |
| Значение по умолчанию                       | Возвращает, **но не сохраняет** | Возвращает и **сохраняет**             |
| Типичный сценарий                           | Безопасно читать                | Читать **и при необходимости создать** |

---

## 3.Практическое использование

### Задача 1

Имеется текст в нижнем регистре.
Необходимо получить словарь, где
 - ключ - это символ
 - значение - сколько раз этот символ встречается в строке

```python
text = 'Что говорить, когда нечего говорить?'.lower()

# --- 1. variant c .get() ---

d = {}
for char in text:
    d[char] = d.get(char, 0) + 1

print(d)
# {'ч': 2, 'т': 3, 'о': 7, ' ': 4, 'г': 4, 'в': 2, 'р': 2, 'и': 2, 'ь': 2, ',': 1, 'к': 1, 'д': 1, 'а': 1, 'н': 1, 'е': 2, '?': 1}

# --- 2. variant c .setdefault() ---

d = {}
for char in text:
    d[char] = d.setdefault(char, 0) + 1

print(d)
# {'ч': 2, 'т': 3, 'о': 7, ' ': 4, 'г': 4, 'в': 2, 'р': 2, 'и': 2, 'ь': 2, ',': 1, 'к': 1, 'д': 1, 'а': 1, 'н': 1, 'е': 2, '?': 1}
```

### Задача 2

Усложним предыдущую задачу. Теперь
 - значение - это список, в котором содержится столько единиц, сколько раз раз этот символ встречается в строке

```python
from pprint import pprint

text = 'Что говорить, когда нечего говорить?'.lower()

# --- 1. variant c .get() ---

d = {}
for char in text:
    d[char] = d.get(char, [])
    d[char].append(1)

pprint(d)
# { ' ': [1, 1, 1, 1],
#   ',': [1],
#   'в': [1, 1],
#   'г': [1, 1, 1, 1],
#   'д': [1],
# ...


# --- 2. variant c .setdefault() ---

d = {}
for char in text:
    d.setdefault(char, []).append(1)

print(d)
# { ' ': [1, 1, 1, 1],
#   ',': [1],
#   'в': [1, 1],
#   'г': [1, 1, 1, 1],
#   'д': [1],
# ...
```

### Выводы

* В задаче 3.1. методы практически равноправны (разве что `get()` чуть короче, а значит - лучше)
* В задаче 3.2. явное преимущество за методом `.setdafault()`

Поэтому,
* если значение `mutable` удобнее использовать `.setdafault()`.
* И наоборот, для `immutable` значений обычно удобнее метод `.get()`








