## `frozenset`

 — это **неизменяемое (immutable)** множество в Python. 

В отличие от обычного `set`, его элементы нельзя изменять после создания:  
нельзя добавлять, удалять или изменять элементы.


## Способы создания

| Способ                                              | Пример                 | Результат                 |
|:----------------------------------------------------| :--------------------- |:--------------------------|
| Пустое множество                                    | `frozenset()`          | `frozenset()`             |
| Из любого `iterable` <br>с неизменяемыми элементами | `frozenset(range(3))`  | `frozenset({0, 1, 2})`    |


## Свойства

| Свойство                    | Описание                                                           |
| :-------------------------- | :----------------------------------------------------------------- |
| **Неизменяемость**          | После создания нельзя добавить или удалить элементы                |
| **Хэшируемость**            | Можно использовать как ключ в `dict` или элемент другого множества |
| **Порядок не сохраняется**  | Как и в `set`, элементы неупорядочены                              |
| **Не допускает дубликатов** | Повторяющиеся элементы удаляются автоматически                     |



## Методы

Методы, доступные у `frozenset`, — только **неизменяющие** операции над множествами:

| Метод                         | Описание                               | Пример                            |
| :---------------------------- | :------------------------------------- | :-------------------------------- |
| `copy()`                      | Возвращает копию множества             | `fs.copy()`                       |
| `union(*others)`              | Объединение                            | `fs.union({3, 4})`                |
| `intersection(*others)`       | Пересечение                            | `fs.intersection({2, 3})`         |
| `difference(*others)`         | Разность                               | `fs.difference({1})`              |
| `symmetric_difference(other)` | Симметрическая разность                | `fs.symmetric_difference({3, 4})` |
| `issubset(other)`             | Проверка, является ли подмножеством    | `fs.issubset({1, 2, 3})`          |
| `issuperset(other)`           | Проверка, является ли надмножеством    | `fs.issuperset({1})`              |
| `isdisjoint(other)`           | Проверка, не пересекаются ли множества | `fs.isdisjoint({5, 6})`           |

Методов `add()`, `remove()`, `discard()`, `clear()` — ОТСУТСТВУЮТ.



## Сравнение `set` и `frozenset`

| Критерий                                | `set`                           | `frozenset`             |
| :-------------------------------------- |:--------------------------------|:------------------------|
| Изменяемость                            | ✅ изменяемый                    | ❌ неизменяемый          |
| Хэшируемость                            | ❌ нет                           | ✅ да                    |
| Можно быть элементом множества          | ❌ нет                           | ✅ да                    |
| Можно быть ключом словаря               | ❌ нет                           | ✅ да                    |
| Методы изменения (`add`, `remove`)      | ✅ есть                          | ❌ нет                   |
| Методы объединения, пересечения и т. д. | ✅ есть                          | ✅ есть                  |
| Производительность                      | немного медленнее `frozenset`'a | немного быстрее `set`'a |

---

## Пример

```python
a = frozenset([1, 2, 3])
b = {3, 4, 5}

immutable_set = frozenset([1, 2, 3])

new_set = immutable_set.union({4, 5})
print(new_set)  # frozenset({1, 2, 3, 4, 5})

new_set2 = {4, 5}.union(immutable_set)
print(new_set2) # {1, 2, 3, 4, 5}

print(immutable_set | {4, 5})   
# frozenset({1, 2, 3, 4, 5})

print({4, 5} | immutable_set)
# {1, 2, 3, 4, 5}

```

### Объект какого типа данных появится в результате взаимодействия `set` и `frozenset`?

Тип результата определяется типом объекта, на котором вызван метод.  
(Иными словам: тип данных результата определяется типом ЛЕВОГО объекта)