### 1. Что такое магические методы итерации

Основные магические методы для итерации:

#### 1.1. `__iter__()`

* Обычно **возвращает сам объект-итератор** (`return self`), если класс реализует и `__iter__`, и `__next__` одновременно.
* Инициализирует необходимые атрибуты для начала итерации, например указатель на текущий элемент.

#### 1.2. `__next__()`

Содержит основную логику итератора:

1. **Логика получения следующего элемента** — как определить, что возвращать на текущем шаге.
2. **Ссылка на коллекцию или данные**, по которым происходит итерация (или генерация элемента).
3. **Указатель на текущую позицию** — чтобы знать, какой элемент возвращать следующим.
4. **Вызов `StopIteration`** — когда элементы исчерпаны, чтобы остановить цикл `for` или другую итерацию.

---

#### Таким образом:

* `__iter__()` → подготовка и возврат итератора.
* `__next__()` → шаг итерации: вернуть элемент или остановить итерацию.

---

### 2. Зачем нужны магические методы итерации

1. Позволяют **создавать свои последовательности** и коллекции, по которым можно проходить в цикле `for`.
2. Делают объекты **совместимыми с Python-функциями**, которые работают с итерируемыми объектами (`sum()`, `list()`, `any()`, `all()`).
3. Упрощают **ленивые вычисления**, когда элементы создаются по мере необходимости (например, бесконечные генераторы).

---

### 3. Пример реализации итератора

Создадим класс, который итерируется по диапазону чисел:

```python
class MyRange:
    def __init__(self, start, end):
        self.start = start
        self.end = end

    def __iter__(self):
        self.current = self.start
        return self

    def __next__(self):
        if self.current >= self.end:
            raise StopIteration  # Конец итерации
        value = self.current
        self.current += 1
        return value

# Использование
for number in MyRange(1, 5):
    print(number)
```

**Вывод:**

```
1
2
3
4
```

---

### 4. Как это работает

1. Цикл `for` вызывает у объекта метод `__iter__()`, чтобы получить **итератор**.
2. Далее `for` многократно вызывает метод `__next__()`.
3. Когда `__next__()` вызывает `StopIteration`, цикл останавливается.

---

### 5. Вариант использования генератора в `__iter__`

* Можно использовать отдельный класс для итератора или возвращать **генератор** из `__iter__()`.
* Генераторы (`yield`) упрощают создание итераторов без явного `__next__()`.

Пример с генератором:

```python
class MyRangeGen:
    def __init__(self, start, end):
        self.start = start
        self.end = end

    def __iter__(self):
        current = self.start
        while current < self.end:
            yield current
            current += 1
```

Работает точно так же, но код проще.

