## 1. Алгоритмы поиска

Представим себе, что у нас есть список:

```python
arr = [42, 17, 8, 99, 23, 56]
```

и нам нужно проверить, есть ли там число `99`.

### 1. Линейный поиск (naive search)

Самый простой способ — пройтись по всем элементам:

```python
for x in arr:
    if x == 99:
        print("Нашли!")
```

Время: **O(n)** — чем больше данных, тем дольше.

---

### 2. Бинарный поиск

Если список отсортирован:

```python
arr = [8, 17, 23, 42, 56, 99]
```

то можно искать быстрее — <a href="https://en.wikipedia.org/wiki/Binary_search#/media/File:Binary-search-work.gif" target="_blank">**бинарным поиском**</a>.  
Суть: берём середину и отбрасываем половину данных на каждом шаге.

Время: **O(log n)** — быстро, но требует *упорядоченности*.

---

### Идея: а можно ли искать за O(1)?

То есть — мгновенно, без обходов и сортировок, вне зависимости от числа данных.
Да, если **мы сразу знаем, где лежит элемент**.
Например, как если бы у нас был словарь с адресами:

| Ключ | Адрес в памяти |
| ---- | -------------- |
| 42   | 0x001          |
| 17   | 0x002          |
| ...  | ...            |

Тогда поиск — это просто «сходить по адресу».
Вот ради этого и придумали **хеширование**.

---

## 2. Обычные и односторонние функции

Чтобы знать, *куда* класть объект, нужно вычислить **его адрес**.
Но мы не можем хранить адреса всех возможных значений (иначе теряет смысл сама идея мгновенного поиска).  
Нам нужна **функция**, которая по значению возвращает «номер ячейки» — некий индекс.

Пример:

```python
f(17) = 2
f(99) = 5
```

[Пример обычных (обратимых) и односторонних функций (необратимых)](./T_career_hub/PD_Python/17__hash__set/theory_98_function_graphs.py)

### Обычная функция (обратимая функция или `invertible function`)

Это функция $y = f(x)$, для которой **одинаково легко**:

* вычислить значение `y` по известному `x`,
* и найти исходный аргумент `x` по известному `y`.

Иными словами, такая функция имеет **эффективно вычислимое обратное отображение** $f^{-1}(y) = x$.


### Односторонние функции (`one-way function`)

Это функция $y=f(x)$, которую **легко вычислить**, но **трудно обратить**.

То есть: 
* вычислить $y$ по $x$ можно быстро (за полиномиальное время);
* а, вот наоборот, найти $x$ по $y$ — вычислительно неосуществимо (занимает экспоненциальное время).

---

## 3. Организация хеш-таблицы

Хэш-таблица в Python — это структура данных, которая хранит элементы по уникальному хэш-коду   
и позволяет быстро находить, добавлять и удалять данные по ключу.

[Пример](./theory_99_hash_table.py)


## 4. Особенности хэш-таблицы:

* Работает ТОЛЬКО c неизменяемыми типами данных (иначе в процессе изменится адрес!)
* Возможны коллизии (разные объекты могут иметь одинаковый хэш!)

Поэтому второе название неизменяемых типов данных - хэшируемые `hashable`. 

```python
x = "abd"
print(x.__hash__())  # -3710920539855426540

x = [1, 2, 3]
print(x.__hash__)  # None

x = [1, 2, 3]
print(x.__hash__())  # TypeError: 'NoneType' object is not callable
```

Неизменяемые типы данных имеют метод `.__hash__()` (возвращает хэш объекта).

У изменяемых - только атрибут `.__hash__` (всегда `None`).  

